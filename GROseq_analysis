####################################
# GRO-seq alignment and read counting
# THIS IS SHELL SCRIPT
####################################

# 1) Downloading bowtie index
wget ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/000/001/405/GCA_000001405.15_GRCh38/seqs_for_alignment_pipelines.ucsc_ids/GCA_000001405.15_GRCh38_no_alt_plus_hs38d1_analysis_set.fna.bowtie_index.tar.gz .

# 2) Run bowtie
module load bowtie2/2.4.2 samtools/1.3.1
bowtie2 -p 20 -x ~/genome_bfa/GRCh38/bowtie/GRCh38 -1 ./lane1/R1.fastq.gz,./lane2/R1.fastq.gz -2 ./lane1/R2.fastq.gz,./lane2/R2.fastq.gz -X 2000 --no-mixed --no-discordant | samtools sort -o sorted.bam -@ 20 -m 1G -
## Do this for all data 

# 3) Make all gencode V38 transcripts

cat gencode.v38.basic.annotation.genePred | 
awk '{OFS="\t"; print $2,$4,$5,$1,".",$3}' | 
sort -k1,1 -k2,2n > gencode.v38.basic.annotation_alltranscript_k1sort.bed

# 4) Counting 5'end of reads

	# In NEBNext directional RNA-seq library prep:
	# READ2 reads from the 5'end of fragmented RNAs
	# READ1 reads from the 3' end of the reverse complement of the fragmented RNAs.
	# So, we will extract READ2 5' end because this is the position where Pol II was located before run-on.
	# SAM flag 131: proper pair, second in pair 	

process_GROseq_v1.sh sorted.bam string gencode.v38.basic.annotation_alltranscript_k1sort.bed
# Do this for all bam files

###########################################
# FROM HERE IN R
###########################################

###################################################
# 1) Load raw counts 
###################################################

## Do NOT use tpm in this Robject. They are not from batch corrected counts. 

# requires
library(data.table)
my_genes <- fread(file="gencode.v38.basic.annotation_pergene.bed") %>% dplyr::rename(chr="#chr") %>% as.data.frame
my_samples <- fread(file="fucci_samples.txt") %>% dplyr::filter(data_type=="GRO") %>% as.data.frame
my_count <- fread(file="gro_rawcount.txt") %>% as.data.frame


###################################################
# 2) Batch correction
###################################################

my_count_wide <- my_count %>%
	pivot_wider(id_cols=transcript_id, names_from=seq_id, values_from=count) %>%
	inner_join(my_genes %>% select(gene_id, transcript_id), by="transcript_id") %>%
	select(-transcript_id) %>%
	column_to_rownames("gene_id")

library(sva)

my_count_adj_wide <- ComBat_seq(
  as.matrix(my_count_wide), 
  batch=my_samples$biorep, 
  group=my_samples$stage
)

###################################################
# 3) Compute TPM
###################################################

my_count_tpm_long <- my_count_adj_wide %>%
	as.data.frame %>%
	rownames_to_column("gene_id") %>%
	pivot_longer(cols= -gene_id, names_to="seq_id", values_to="count") %>%
	mutate(seq_id=factor(seq_id)) %>%
	left_join(my_genes %>% select(gene_id, txstart, txstop), by="gene_id") %>%
	mutate(rpk=(1+count)*10^3/(txstop-txstart)) %>%
	group_by(seq_id) %>%
	mutate(tpm=rpk*10^6/sum(rpk)) %>%
	ungroup %>%
	select(gene_id, seq_id, count, tpm)	

###################################################
# 4) Compute mean log10 TPM and z-score per stage 
###################################################

my_logtpm_z_wide <- my_count_tpm_long %>%
	left_join(my_samples, by="seq_id") %>%
	group_by(gene_id, stage) %>%
	summarize(logtpm_m=mean(log10(tpm))) %>%
	ungroup %>%
	group_by(gene_id) %>%
	mutate(logtpm_z=scale(logtpm_m, scale=T)) %>%
	ungroup %>%
	pivot_wider(id_cols=gene_id, names_from=stage, values_from=c(logtpm_m, logtpm_z))

###################################################
# 5) DESeq2
###################################################

library(DESeq2)

## Corrected count matrx for DESeq2
my_dds_count <- my_count_tpm_long %>%
    dplyr::select(-tpm) %>%
    pivot_wider(names_from=seq_id, values_from=count) %>%
    column_to_rownames("gene_id")

dds <- NULL;
dds <- DESeqDataSetFromMatrix(
    countData = my_dds_count, 
    colData = my_samples, 
    design = ~ stage
)

## Run DESeq2
dds <- DESeq(dds)


## Apply cutoff and extract relevant data
gro.eg1.g1 <- extract.deseq(dds, "gro.eg1.g1_de05.lfc05", 0.05, 0.5, "gene_id", "stage", "G1", "EG1")
gro.g1.g2 <- extract.deseq(dds, "gro.g1.g2_de05.lfc05", 0.05, 0.5, "gene_id", "stage", "G2", "G1")
gro.g2.eg1 <- extract.deseq(dds, "gro.g2.eg1_de05.lfc05", 0.05, 0.5, "gene_id", "stage", "EG1", "G2")

### See R_function for custom function extract.deseq 

## Combine as a wide format
gro_degene_wide <- gro.eg1.g1 %>%
    left_join(gro.g1.g2, by="gene_id") %>%
    left_join(gro.g2.eg1, by="gene_id")

###################################################
# 6) k means clustering 
###################################################

## Extract gene_id for union DE genes 
degene_union <- gro_degene_wide %>%
	dplyr::filter(!if_all(.cols=c(gro.eg1.g1_de05.lfc05.3bin, gro.g1.g2_de05.lfc05.3bin, gro.g2.eg1_de05.lfc05.3bin), ~ .x == "no")) %>%
	dplyr::select(gene_id)

> dim(degene_union)
[1] 2771    1

## Make logtpm_z matrix for kmeans
my_kdat <- my_logtpm_z_wide %>%
	inner_join(degene_union, by="gene_id") %>%
	dplyr::select(gene_id, starts_with("logtpm_z")) %>%
	column_to_rownames("gene_id")

## Run k-means
i=6
set.seed(109)
k.out <- kmeans(my_kdat, i, nstart=50, iter.max=50)

gro_k6_wide <- data.frame(my_k=k.out$cluster) %>%
	rownames_to_column(var="gene_id") %>%
	group_by(my_k) %>%
	mutate(sum=length(gene_id)) %>%
	ungroup %>%
	mutate(gro_k6=factor(case_when(
   	sum==84 ~ "a",
   	sum==480 ~ "b",
      sum==515 ~ "c",
      sum==206 ~ "d",
      sum==685 ~ "e",
      sum==801 ~ "f",
   ), levels=c("a","b","c","d","e","f")))	%>%
	dplyr::select(gene_id, gro_k6)

###################################################
# 7) PCA
###################################################

my_logtpm <- my_count_tpm_long %>%
	left_join(my_samples, by="seq_id") %>%
	group_by(gene_id) %>%
	mutate(min=min(tpm)) %>%
	ungroup %>%
	dplyr::filter(min > 10) %>%
	mutate(logtpm=log10(tpm)) %>%
	group_by(seq_id) %>%
	mutate(logtpm=scale(logtpm)) %>%
	ungroup %>%
	select(gene_id, seq_id, logtpm) %>%
	pivot_wider(names_from=seq_id, values_from= logtpm) %>%
	column_to_rownames(var="gene_id")

my_pca <- prcomp(t(my_logtpm), scale=F)

as.data.frame(my_pca$x) %>%
   rownames_to_column(var="seq_id") %>%
   left_join(my_samples, by="seq_id") %>%
   ggplot(
	   aes(x=PC1, y=PC2, color=stage, shape=factor(biorep), label=seq_id)
   ) +
   geom_point(size=5) +
	geom_text(nudge_x=2)


###################################################
# 8) Write data
###################################################

## Batch-corrected count and tpm in long format
saveRDS(my_count_tpm_long, file = "GRO_count_tpm_long.rds")

## Processed data in wide format
my_logtpm_z_degene_k6_wide <- my_genes %>%
	dplyr::select(gene_id:txlength) %>%
	left_join(my_logtpm_z_wide, by="gene_id") %>%
	left_join(gro_degene_wide, by="gene_id") %>%
	left_join(gro_k6_wide, by="gene_id")

saveRDS(my_logtpm_z_degene_k6_wide, file = "GRO_logtpm_z_degene_k6_wide.rds")


## Supplemental file

my_logtpm_z_degene_k6_wide %>%
	left_join(my_count_tpm_long %>%
		pivot_wider(id_cols=gene_id, names_from=seq_id, values_from=tpm, names_prefix="tpm_"), 
   	by="gene_id"
   ) %>%
	dplyr::select(gene_id:txlength, starts_with("tpm"), starts_with("logtpm_m"), starts_with("logtpm_z"), ends_with(".3bin"), gro_k6) %>% 
	mutate(
      across(
         c(starts_with("tpm_"), starts_with("logtpm_m_"), starts_with("logtpm_z_")), 
      	~ round(.x, 3))
   ) %>%
	write.csv(file="gro_suppl.csv", row.names=F, quote=F)

